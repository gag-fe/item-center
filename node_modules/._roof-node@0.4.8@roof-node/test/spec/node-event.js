var assert = require("assert")
var _ = require("lodash")
var Node = require("../../lib/node")
var async = require("async")

var User = Node.createClass({
  push : [function(){
    return new Promise(resolve=>{
      this.set('id', Date.now())
      setTimeout(resolve, 50)
    })
  }, 'push.initial', 'push.processing', 'push.end']
})


describe("state event test", function(){

  it("state change should fire event", function(done){
    var miya = new User
    var setFired = false
    var changeFired = false
    async.parallel([
      function( cb ){
        miya.on("set.called", function ( val, oldVal){
          setFired = true
          assert.equal( val, 'set.called')
          assert.equal( oldVal, 'set.uncalled')
          cb()
        })
      },
      function( cb ){
        miya.on('change', function (val, oldVal, detail){
          if( !changeFired){
            changeFired = true
            assert.equal( val, 'set.called')
            assert.equal( oldVal, 'set.uncalled')
            assert.equal( detail.type, 'naive')
            assert.equal( detail.state, 1)
            cb()
          }
        })
      }
    ], function(err){
      assert.equal( setFired, true)
      assert.equal( changeFired, true)
      done(err)
    });

    miya.set("name","miya")
  })

  it("action change should fire event", function(done){
    var miya = new User
    var changeFired = 0
    async.parallel([
      function( cb ){
        miya.on("push.processing", function( val, oldVal){
          assert.equal( val, 'push.processing')
          assert.equal( oldVal, 'push.initial')
          cb()
        })
      },
      function( cb ){
        miya.on("push.end", function( val, oldVal){
          assert.equal( val, 'push.end')
          assert.equal( oldVal, 'push.processing')
          cb()
        })
      },
      function( cb ){
        miya.on("change", function shouldFireTwice( val, oldVal, detail){
          if( changeFired == 0 ){
            assert.equal( val, 'push.processing')
            assert.equal( oldVal, 'push.initial')
            assert.equal( detail.type, 'normal')
            assert.equal( detail.state, 1)
            changeFired ++
          }else if( changeFired ==1 ){
            assert.equal( val, 'push.end')
            assert.equal( oldVal, 'push.processing')
            assert.equal( detail.type, 'normal')
            assert.equal( detail.state, 2)
            changeFired ++
            cb()
          }
        })
      }
    ], function(){
      assert.equal( changeFired, 2)
      done()
    });

    miya.push()
  })

  it("once should fire only once", function(){
    var jane = new User
    var fired = 0
    jane.once("set.called", function(){
      fired ++
    })
    jane.set("name","jane")
    jane.set("name","jone")

    assert.equal( fired, 1)
  })

  it("should receive destroy event", function(){
    var jane = new User
    var destroyed = 0
    jane.on("destroy", function(){
      destroyed ++
    })
    jane.destroy()

    var error = null
    assert.equal( destroyed, 1)
    try{
      jane.destroy()
    }catch(e){
      error = e
    }

    assert.equal( destroyed, 1)
    assert.notEqual( error, null)
  })

})