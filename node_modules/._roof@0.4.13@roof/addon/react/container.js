'use strict'
var Roof = require('roof')
require('./globalManage')(Roof)
var Galaxy = require('../../lib/Galaxy')
var Bus = require('roof').Bus;
var util = require('../../lib/util')
var React = require('react')
var Mixin = require('./mixin/react.js')

//////////////////////////////////
//         SourceReadyMixin
//////////////////////////////////
function SourceReadyMixin(source) {
  var forceUpdate

  return {
    componentDidMount: function () {
      forceUpdate = this.forceUpdate.bind(this)
      source.on('ready', forceUpdate)
      source.on('error', forceUpdate)
    },
    componentWillUnmount: function () {
      source.removeListener('ready', forceUpdate)
      source.removeListener('error', forceUpdate)
    }
  }
}


//////////////////////////////////
//         createRootContainer
//////////////////////////////////

//0.4 版开始支持多 Roof 实例渲染
function createRootContainer(def) {
  def = util.assign({}, def)

  //处理 context
  def.childContextTypes = util.assign( def.childContextTypes||{},{
    app: React.PropTypes.any.isRequired,
    subscribed: React.PropTypes.any.isRequired,
  })

  util.decorate(def,'getChildContext' , function (_origin) {
    var context = {
      app: this.app,
      subscribed : []
    };
    if( _origin){
      util.assign(context,_origin.call(this))
    }
    return context
  })

  util.hook(def, 'getInitialState', function(){
    //所有实例运行时的数据必须放在这里
    //内置event center
    this.app = {
      bus: new Bus,
      data :  new Galaxy(def.data )
    }



    var that = this
    //初始化bus
    if( def.events === undefined && def.event !== undefined){
      console.warn('Roof use attribute name `events` to receive listener, not `event`. Did you misspell it?')
    }

    for( var moduleName in def.events ){
      that.app.bus._module.set(moduleName)
      var events = def.events[moduleName]( that.app.data )
      for( var eventName in events ){
        var listeners = [].concat( events[eventName] )
        listeners.forEach(function( listener){
          that.app.bus.on(eventName, listener)
        })
      }
    }
  })

  util.hook(def,'componentDidMount', function(){
    if( this.props.instanceName !== undefined ){
      Roof.Sources._register(this.props.instanceName, this.app.data)
    }
  })

  util.hook(def,'componentWillUnmount', function(){
    if( this.props.instanceName !== undefined ){
      Roof.Sources._remove(this.props.instanceName)
    }
  })

  //对常用错误提示
  if( def.cursors !== undefined) console.warn('you cannot use cursors in Roof.createRootContainer, use it in Roof.createContainer.')

  return React.createClass(def)
}



//////////////////////////////////
//         createContainer
//////////////////////////////////
function addContextToDef( def, isContainer ){

  def.contextTypes = util.assign(def.contextTypes||{},{
    app: React.PropTypes.any.isRequired,
    subscribed: React.PropTypes.any.isRequired,
  })

  if( isContainer ){
    def.childContextTypes = util.assign(def.childContextTypes||{},{
      app: React.PropTypes.any.isRequired,
      subscribed: React.PropTypes.any.isRequired,
    })

    def.displayName = 'RoofContainer'

    util.decorate(def,'getChildContext' , function (_origin) {
      var context = {
        app: this.context.app,
        subscribed : util.union( this.context.subscribed, util.values(def.cursors) )
      };
      if( _origin){
        util.assign(context,_origin.call(this))
      }
      return context
    })
  }


  util.hook(def, 'componentDidMount', function(){
    this.app = this.context.app
    //shortcut
    this.bus = this.context.app.bus
  })
}


function unBindProxyAndContainer( cursors, com ){
  Object.keys(cursors).forEach( function( name) {
    com.sources[name].off('change', com.safeForceUpdate )
    if( com.sources[name].offAny ){
      com.sources[name].offAny('change', com.safeForceUpdate )
    }
  })
}

function subscribeDataForContainer( cursors, com, emitChangeOnEachReady ){
  var promises = []
  Object.keys(cursors).forEach( function( name) {
    var sourceName = cursors[name]

    var data = com.context.app.data.get(sourceName, true)

    //父Container订阅过的自己就不订阅了
    if( com.context.subscribed.indexOf( sourceName ) !== -1 ){
      com.sources[name] = data
      return
    }

    //因为 Promise 默认会扔到 nextTick 中执行
    //所以为了支持服务器端渲染，必须区别对待
    if( data instanceof  Promise ){
      promises.push(
        data.then(
          bindSource.bind(null,com, emitChangeOnEachReady)))
    }else{
      bindSource(com, emitChangeOnEachReady, data)
    }

    function bindSource(com, emitChangeOnEachReady, source){
      com.sources[name] = source
      source.on('change', com.safeForceUpdate )
      if( source.onAny ){
        source.onAny('change', com.safeForceUpdate)
      }

      if( emitChangeOnEachReady ) com.safeForceUpdate()
    }
  })

  //TODO 这里还要判断 sync 情况下出错怎么办
  if( promises.length === 0 ){
    com.ready = true
    //不需要，因为现在 subscribe 移到 getInitialize 里面
    //com.safeForceUpdate()
  }else{
    Promise.all( promises ).then( function(){
      com.ready = true
      com.safeForceUpdate()
    })['catch'](function(err){
      com.error = err
      console.error(err)
      com.safeForceUpdate()
    })
  }
}

function AddLifeCycleCallbackForContainer( def, Component ){

  def['getInitialState']= function(){
    var that = this
    this.instanceName = this.props.instanceName || def.name
    //仍然保留这种方式，服务器端渲染的时候nextTick可能会导致dom没有及时被渲染出来
    this.safeForceUpdate = function(){
      that.setState({timestamp : +new Date()})
    }

    //暂时不处理，处理完了之后需要测试都要改
    //if( typeof window !== 'undefined'){
    //  var shouldUpdate = false
    //  this.safeForceUpdate = function(){
    //    if( shouldUpdate === true ) return
    //    shouldUpdate = true
    //    window.setTimeout(function(){
    //      that.setState({timestamp : Date.now()})
    //      shouldUpdate = false
    //    },0)
    //  }
    //}

    this.sources = {}
    this.ready = false
    this.error = null

    if( def.cursors!==undefined){
      subscribeDataForContainer(def.cursors, this, def.renderBeforeReady !== undefined)
    }

    return {}
  }

  def['componentDidMount']= function () {
    //改从 getInitialState 中订阅，这样才能从服务器端渲染
  }


  def['componentWillUnmount']=function () {
    //解绑所有订阅? 因为组件都已经被移除了?
    if( def.cursors!==undefined) {
      unBindProxyAndContainer(def.cursors, this)
    }
  }

  //重写 render
  def['render'] = function(){
    //if 的顺序不能乱，先检测error
    if( this.error ){

      if( def.renderWhenError === undefined  ) {
        console.log('Data initialize failed, you may want to implement `renderWhenError` callback')
        return null
      }
      return def.renderWhenError.call(this)

    }else if( this.ready === true ){
      var conflictNames = util.intersection( Object.keys(this.props), Object.keys(this.sources) )
      if( conflictNames.length!==0){
        throw new Error('property name and cursor name conflict: '+conflictNames.join(','))
      }

      var props = util.assign({}, this.props, this.sources)
      return React.createElement(Component, props)

    }else{

      if( def.renderBeforeReady === undefined  ) {
        console.log('Data not ready, you may want to implement `renderBeforeReady` callback')
        return null
      }
      return def.renderBeforeReady.call(this)
    }

  }
}


function createContainer( def) {
  var componentDef = util.pick(def, util.without(Object.keys(def), ['cursors','renderBeforeReady','renderWhenError']))



  //context是都必须要的，所以必须放前面
  addContextToDef(componentDef)
  var Component = React.createClass(componentDef)



  var containerDef = util.pick(def, ['renderBeforeReady','cursors','renderWhenError'])

  //常见错误
  if( containerDef.cursors === undefined ){
    console.warn('cannot find cursors in React.createContainer. Did you forget it?')
    containerDef.cursors = {}
  }

  addContextToDef(containerDef, true)


  AddLifeCycleCallbackForContainer( containerDef, Component )

  return React.createClass(containerDef)
}
///////////////////////////////
//              exports
///////////////////////////////

Roof.createRootContainer = createRootContainer
Roof.createContainer = createContainer



