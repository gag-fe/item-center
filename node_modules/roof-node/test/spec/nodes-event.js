var assert = require("assert")
var _ = require("lodash")
var Node = require("../../lib/node")
var Nodes = require("../../lib/nodes")
var async = require("async")

var pushAction = [function(){
  return new Promise(resolve=>{
    setTimeout( resolve, 50)
  })
},'push.initial','push.processing','push.ended']

var User = Node.createClass({
  push:pushAction
})
var Users= Nodes.createClass( {
  $factory : User,
  push :pushAction
})


describe("events test", function(){

  it("state change should fire event", function(done){
    var users = new Users
    async.parallel([
      function( cb ){
        users.on('push.processing', function( val, oldVal){
          assert.equal( val, 'push.processing')
          assert.equal( oldVal, 'push.initial')
          cb()
        })
      },
      function( cb ){
        users.on('push.ended', function( val, oldVal){
          assert.equal( val, 'push.ended')
          assert.equal( oldVal, 'push.processing')
          cb()
        })
      }
    ], function(err){
      done(err)
    });

    users.push()
  })


  it("sub object event should propagate", function(done){
    var users = new Users
    var user = new User
    async.parallel([
      function( cb ){
        users.onAny('push.processing', function( val, oldVal){

          assert.equal( val, 'push.processing')
          assert.equal( oldVal, 'push.initial')
          cb()
        })
      },
      function( cb ){
        users.onAny('push.ended', function( val, oldVal){
          assert.equal( val, 'push.ended')
          assert.equal( oldVal, 'push.processing')
          cb()
        })
      },
      function(cb){
        users.insert(user)
        cb()
      }
    ], function(err){
      done(err)
    });

    user.push()
  })

  it("sub object destroy should propagate", function(done){
    var users = new Users
    var user = new User
    var destroyFired = false
    async.parallel([
      function( cb ){
        users.onAny("destroy", function( val, oldVal){
          if( !destroyFired ){
            destroyFired = true
            cb()
          }
        })
      },
      function(cb){
        users.insert(user)
        cb()
      }
    ], function(err){
      assert.equal( destroyFired, true)
      done(err)
    });

    user.destroy()
  })

  it('sub object destroy should cause collection change event', function( done){
    var users = new Users([{
      name : 'Jim'
    },{
      name : 'Kyle'
    }])


    users.on('change', function( newState, lastState ){
      assert.equal( newState, 'remove.called')
      assert.equal( lastState, 'remove.uncalled')
      done()
    })

    users.get(0).destroy()
  })

  it("collection on method should not listen on child", function(done){
    var users = new Users
    var changeFired = 0

    users.on('change', function(){
      changeFired ++
    })

    users.insert({name :'ke$ha'})
    users.get(0).set('nane','fill')

    setTimeout(function(){
      assert.equal( changeFired, 1 )
      done()
    },10)

  })

  it('should receive destroy event', function(){
    var users = new Users
    var destroyed = 0

    users.on('destroy', function(){
      destroyed ++
    })


    users.destroy()
    assert.equal( destroyed, 1)

    var error = null
    try{
      users.destroy()
    }catch(e){
      error = e
      console.log( e)
    }

    assert.equal(destroyed, 1)
    assert.notEqual(error, null)

  })
})

